#version 460


out vec4 FragColor;

struct DirectionalLight {
    vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	int used;
};

struct PointLight {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	float constant;
	float linear;
	float quadratic;
	int used;
};

struct SpotLight {
    vec3 position;
	vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	float cutOff;
	float outerCutOff;
	int used;
};

#define NR_POINT_LIGHTS 10
#define NR_SPOT_LIGHTS 10
#define NR_DIR_LIGHTS 10

in vec3 TexCoord;
in vec4 Diffuse;
in vec4 Specular;
in vec3 Normal;
in vec3 FragmentPosition;


uniform PointLight pointLights[NR_POINT_LIGHTS];
uniform SpotLight spotLights[NR_POINT_LIGHTS];
uniform DirectionalLight directionalLights[NR_DIR_LIGHTS]; 
uniform sampler2D atlas[10];

vec3 CalculateDirectionalLights(vec3 normal, vec3 viewDirection);
vec3 CalculatePointLights( vec3 normal,vec3 viewDirection, vec3 fragmentPosition);
vec3 CalculateSpotLights(vec3 normal,vec3 viewDirection, vec3 fragmentPosition);

void main()
{
	
	//----------------------------------------------------------------------------------------------------------------------initial setup
	vec3 normal = normalize(Normal);
	vec3 viewDirection = normalize(vec3(0,0,-1));
	
	
	//----------------------------------------------------------------------------------------------------------------------directional
    vec3 color = CalculateDirectionalLights( normal, viewDirection);
	
	//----------------------------------------------------------------------------------------------------------------------point lights
	color += CalculatePointLights(normal, viewDirection, FragmentPosition);

	//----------------------------------------------------------------------------------------------------------------------spot lights
	color += CalculateSpotLights(normal, viewDirection,FragmentPosition);
		
	//----------------------------------------------------------------------------------------------------------------------result
	FragColor =  texture(atlas[int(floor(TexCoord.z))],vec2(TexCoord.x,TexCoord.y)) * vec4(color, 1.0) * Diffuse;
	
	
	
	
	
	
} 


vec3 CalculateDirectionalLights(vec3 normal, vec3 viewDirection)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float diff;
	float specularStrength;
	
	DirectionalLight light;
	
	
	for(int i = 0; i < NR_DIR_LIGHTS ; i++)
	{
		light = directionalLights[i];
		
		if(light.used == 0) continue;
			
			//----------------------------------------------------------------------------------------------------------------------initial setup
			lightDirection = normalize(-light.direction);
				
			//----------------------------------------------------------------------------------------------------------------------ambient
			result += light.ambient;
			
			//----------------------------------------------------------------------------------------------------------------------diffuse

			diff = max(dot(normal, lightDirection), 0.0);
			result += diff  * light.diffuse ;

			//----------------------------------------------------------------------------------------------------------------------specular
			reflectionDirection = reflect(-lightDirection, normal);
			specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),Specular.w);
			result += light.specular * (specularStrength * vec3(Specular)) ;
		
	}
		//----------------------------------------------------------------------------------------------------------------------result
	return result;	
	
	
}

vec3 CalculatePointLights(vec3 normal,vec3 viewDirection, vec3 fragmentPosition)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float distance ;
	float attenuation;
	float diff;
	float specularStrength;
	
	PointLight light;
	
	
	
	for(int i = 0; i < NR_POINT_LIGHTS ; i++)
	{
		light = pointLights[i];
		if(light.used == 0) continue;	
		
		//----------------------------------------------------------------------------------------------------------------------initial setup
		lightDirection = normalize(light.position - fragmentPosition);
		distance = length(light.position - fragmentPosition);
		attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance*distance));
		
		//----------------------------------------------------------------------------------------------------------------------ambient
		result += light.ambient * attenuation ;
		
		//----------------------------------------------------------------------------------------------------------------------diffuse
		diff = max(dot(normal, lightDirection), 0.0);
		result += diff   * light.diffuse * attenuation ;

		//----------------------------------------------------------------------------------------------------------------------specular
		reflectionDirection = reflect(-lightDirection, normal);
		specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),Specular.w);
		result += light.specular * (specularStrength * vec3(Specular)) * attenuation ;	
	}
	

	//----------------------------------------------------------------------------------------------------------------------result
	return result;

	
	
}

vec3 CalculateSpotLights( vec3 normal,vec3 viewDirection, vec3 fragmentPosition)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float theta;
	float epsilon;
	float intensity;
	float diff;
	float specularStrength;
	
	SpotLight light;
	
	for(int i = 0; i < NR_SPOT_LIGHTS ; i++)
	{
		light = spotLights[i];
		if(light.used == 0) continue;	
		
		//----------------------------------------------------------------------------------------------------------------------initial setup
		lightDirection = normalize(light.position - fragmentPosition);
		
		//----------------------------------------------------------------------------------------------------------------------ambient
		result += light.ambient ;
				
		//----------------------------------------------------------------------------------------------------------------------angle calculations
		theta = dot(lightDirection, normalize(-light.direction));
		epsilon = light.cutOff - light.outerCutOff;
		intensity = clamp((theta - light.outerCutOff)/epsilon, 0.0,1.0);
			
		//----------------------------------------------------------------------------------------------------------------------diffuse
		diff = max(dot(normal, lightDirection), 0.0);
		result += diff   * light.diffuse * intensity;

		//----------------------------------------------------------------------------------------------------------------------specular
		reflectionDirection = reflect(-lightDirection, normal);
		specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),Specular.w);
		result += light.specular * (specularStrength * vec3(Specular)) * intensity ;

	}
	//----------------------------------------------------------------------------------------------------------------------result
	return result;

	
	
}