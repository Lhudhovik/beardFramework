#version 460


out vec4 FragColor;

struct ColorComponent{
	sampler2D sampler;
	vec4 uv;
	vec3 color;
};

struct Material{
	ColorComponent diffuse;
	ColorComponent specular;
	float shininess;
	float transparency;
};

struct DirectionalLight {
    vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	int used;
};

struct PointLight {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	float constant;
	float linear;
	float quadratic;
	int used;
};

struct SpotLight {
    vec3 position;
	vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	float cutOff;
	float outerCutOff;
	int used;
};

#define NR_POINT_LIGHTS 10
#define NR_SPOT_LIGHTS 10
#define NR_DIR_LIGHTS 10


in vec3 FragmentPosition;

uniform PointLight pointLights[NR_POINT_LIGHTS];
uniform SpotLight spotLights[NR_POINT_LIGHTS];
uniform DirectionalLight directionalLights[NR_DIR_LIGHTS]; 
uniform Material material;

vec3 specular;
vec3 diffuse;

vec3 CalculateDirectionalLights(vec3 normal, vec3 viewDirection);
vec3 CalculatePointLights( vec3 normal,vec3 viewDirection, vec3 fragmentPosition);
vec3 CalculateSpotLights(vec3 normal,vec3 viewDirection, vec3 fragmentPosition);

void main()
{
	
	//----------------------------------------------------------------------------------------------------------------------initial setup
	vec3 normal = normalize(vec3(0,0,-1));
	vec3 viewDirection = normalize(vec3(0,0,-1));
	
	diffuse = vec3(texture(material.diffuse.sampler, vec2(material.diffuse.uv.x + (material.diffuse.uv.z*FragmentPosition.x),material.diffuse.uv.y + (material.diffuse.uv.w*FragmentPosition.y)))) *material.diffuse.color; 
	
	specular = vec3(texture(material.specular.sampler, vec2(material.specular.uv.x + (material.specular.uv.z*FragmentPosition.x),material.specular.uv.y + (material.specular.uv.w*FragmentPosition.y)))) *material.specular.color; 

	//----------------------------------------------------------------------------------------------------------------------directional
    vec3 color = CalculateDirectionalLights( normal, viewDirection);
	
	//----------------------------------------------------------------------------------------------------------------------point lights
	color += CalculatePointLights(normal, viewDirection, FragmentPosition);

	//----------------------------------------------------------------------------------------------------------------------spot lights
	color += CalculateSpotLights(normal, viewDirection,FragmentPosition);
		
	//----------------------------------------------------------------------------------------------------------------------result
	//FragColor =  texture(atlas[int(floor(TexCoord.z))],vec2(FragmentPosition.x * material.uv.x,FragmentPosition.y* material.uv.y)) * vec4(color, transparency);
	//FragColor =  vec4(color, material.transparency);
	FragColor =  vec4(diffuse, material.transparency);
	
	
	
	
	
	
} 


vec3 CalculateDirectionalLights(vec3 normal, vec3 viewDirection)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float diff;
	float specularStrength;
	
	DirectionalLight light;
	
	
	for(int i = 0; i < NR_DIR_LIGHTS ; i++)
	{
		light = directionalLights[i];
		
		if(light.used == 0) continue;
			
			//----------------------------------------------------------------------------------------------------------------------initial setup
			lightDirection = normalize(-light.direction);
				
			//----------------------------------------------------------------------------------------------------------------------ambient
			result += light.ambient;
			
			//----------------------------------------------------------------------------------------------------------------------diffuse

			diff = max(dot(normal, lightDirection), 0.0);
			result += diff  * light.diffuse ;

			//----------------------------------------------------------------------------------------------------------------------specular
			reflectionDirection = reflect(-lightDirection, normal);
			specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),material.shininess);
			
			result += light.specular * specularStrength * specular;
		
	}
		//----------------------------------------------------------------------------------------------------------------------result
	return result;	
	
	
}

vec3 CalculatePointLights(vec3 normal,vec3 viewDirection, vec3 fragmentPosition)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float distance ;
	float attenuation;
	float diff;
	float specularStrength;
	
	PointLight light;
	
	
	
	for(int i = 0; i < NR_POINT_LIGHTS ; i++)
	{
		light = pointLights[i];
		if(light.used == 0) continue;	
		
		//----------------------------------------------------------------------------------------------------------------------initial setup
		lightDirection = normalize(light.position - fragmentPosition);
		distance = length(light.position - fragmentPosition);
		attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance*distance));
		
		//----------------------------------------------------------------------------------------------------------------------ambient
		result += light.ambient * attenuation  ;
		
		//----------------------------------------------------------------------------------------------------------------------diffuse
		diff = max(dot(normal, lightDirection), 0.0);
		result += diff   * light.diffuse * diffuse *  attenuation ;

		//----------------------------------------------------------------------------------------------------------------------specular
		reflectionDirection = reflect(-lightDirection, normal);
		specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),material.shininess);
		result += light.specular * specularStrength * specular * attenuation ;	
	}
	

	//----------------------------------------------------------------------------------------------------------------------result
	return result;

	
	
}

vec3 CalculateSpotLights( vec3 normal,vec3 viewDirection, vec3 fragmentPosition)
{
	vec3 result = vec3(0,0,0);
	vec3 lightDirection;
	vec3 reflectionDirection;
	
	float theta;
	float epsilon;
	float intensity;
	float diff;
	float specularStrength;
	
	SpotLight light;
	
	for(int i = 0; i < NR_SPOT_LIGHTS ; i++)
	{
		light = spotLights[i];
		if(light.used == 0) continue;	
		
		//----------------------------------------------------------------------------------------------------------------------initial setup
		lightDirection = normalize(light.position - fragmentPosition);
		
		//----------------------------------------------------------------------------------------------------------------------ambient
		result += light.ambient ;
				
		//----------------------------------------------------------------------------------------------------------------------angle calculations
		theta = dot(lightDirection, normalize(-light.direction));
		epsilon = light.cutOff - light.outerCutOff;
		intensity = clamp((theta - light.outerCutOff)/epsilon, 0.0,1.0);
			
		//----------------------------------------------------------------------------------------------------------------------diffuse
		diff = max(dot(normal, lightDirection), 0.0);
		result += diff   * light.diffuse * diffuse * intensity ;

		//----------------------------------------------------------------------------------------------------------------------specular
		reflectionDirection = reflect(-lightDirection, normal);
		specularStrength = pow(max(dot(viewDirection, reflectionDirection),0.0),material.shininess);
		result += light.specular * specularStrength * specular * intensity ;

	}
	//----------------------------------------------------------------------------------------------------------------------result
	return result;

	
	
}